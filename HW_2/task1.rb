arr = [621, 445, 147, 159, 430, 222, 482, 44, 194, 
  522, 652, 494, 14, 126, 532, 387, 441, 471, 337, 446, 18, 
  36, 202, 574, 556, 458, 16, 139, 222, 220, 107, 82, 264, 366, 
  501, 319, 314, 430, 55, 336]

arr.size #1 узнать количество элементов в массиве
arr.reverse #2 перевернуть массив
arr.max #3 найти наименьшее число
arr.min #4 найти наибольшее число
arr.sort #5 отсортировать от меньшего к большему
arr.sort.reverse #6 отсортировать от большего к меньшему
(arr.reject { |e| arr.count(e) == &:odd? }) #7 удалить все нечетные числа
arr.find_all{ |elem| elem % 3 == 0 } #8 оставить только те числа, которые без остатка делятся на 3
(arr.reject { |e| arr.count(e) > 1 }) #9 удалить из массива числа, которые повторяются (то есть, нужно вывести массив, в котором нет повторов)
(arr.map { |e| e/10 }) #10 разделить каждый элемент на 10, в результате элементы не должны быть округлены до целого

#11 получить новый массив, который бы содержал в себе те буквы английского алфавита, порядковый номер которых есть в нашем массиве
arr1=('a'..'z').to_a #????????????????????????????????
arr_l=Array.new()
puts arr.size
(0..arr.size-1).each do |i|
  (0..arr1.size-1).each do |y|
    if arr[i]==y
      arr_l << new_mass[y]
    end
end
end
print arr_l

arr1=arr #12 поменять местами минимальный и максимальный элементы массива
i = arr1.e_index.min[1] #????????????????????????????????
j = arr1.e_index.max[1]
arr1[i],arr1[j]=arr1[j],arr1[i]
print arr1 
arr.all?(arr.min) #13 найти элементы, которые находятся перед минимальным числом в массиве
arr.sort[0..2] #14 необходимо найти три наименьших элемента
